# 为什么选择洛书?

## 简单

洛书编程语言采用汉语编程，作为母语，洛书学习起来毫不费劲，让更多的人爱上编程！

汉语源代码使得洛书源代码阅读起来更简单，更方便，让更多的人能够享受开源，而不是因英文代码而晕头转向，让更多的人爱上汉语编程！

反杠精：有些人认为编程是一种使用符号与计算机对话的方式，汉语编程没有必要。那么，为什么人们不用二进制写代码呢？二进制不也是符号吗？（doge）

## 开放

洛书的源代码完全公开透明，供所有人学习与参考。

也希望大家能够共同参与进洛书的社区建设中来！

## 自研
洛书由仓库持有者陈朝臣原创编写，不是套壳语言(language on language)！！！

## 快速

不说大话，请看如下代码：

```
//让我们来测一下洛书的运行速度
//编译器 洛书0.1
//解释器 洛书0.1
//代码优化 无
//垃圾回收 全部回收
+加载 开始
+导入 洛书·标准流
+导入 洛书·时间
+实例 标准流 标准流
+实例 时间 时间
//在本人电脑上
//windows11 
//i5处理器 
//内存16G 已用40% 
//powershell
//平均用时0.831秒
//最低达到了0.741秒
//C++编写的等效程序(没引用time类，利用IDE测的控制权返回时间)用时0.725秒
+方法 开始()
{
    时间·计时器()
    开始时间 = <时间·计时器>
    +循环("1000")
    {
        标准流·输出("hello\n")
    }
    时间·计时器()
    结束时间 = <时间·计时器>
    用时 = 结束时间 - 开始时间
    标准流·输出("用时 " & 用时 & "毫秒")
}
//关于运行速度优化
//良好的编程习惯
//改进编译器，减少冗余代码，最典型的就是 api =
//适当减少类库中的回收操作
//将瓶颈代码用C编写为支持库后进行调用

```
人生苦短，我用洛书！


# 第一个洛书程序

## 编写

注意，洛书源代码文件以.losu结尾

```
//这是注释
//让我们从经典的 你好世界 走进洛书
//洛书第一规则  一行只能写一句代码

//设定加载点csip为开始
+加载 开始

//导入编译好的洛书类 文件 LS_ROOT/inc/洛书/标准流
+导入 洛书·标准流

//实例化一个对象，推荐放到方法里实例，实例是写给编译器看到
//对象只在编译时存在，输出文件中只有干货指令，文件很小
+实例 标准流 标准流 

//定义开始方法
+方法 开始()
{
    标准流·输出("你好，洛书编程世界\n")
    /{
        这是多行注释，洛书0.3及以上版本支持
        补充一个小细节
        在linux平台上 如果不加\n 程序结束后是不自动换行的，Windows会自动换行
        \n不是洛书的转义字符
        调用 lvm_io 中的ls_io_cout函数时\n才会被转义为换行
    }

}

```

这个写法太优雅了！

注意事项：
“·”这个符号是中文输入法下按住键盘左上角的“~”按钮打出来的

不过要注意()，{}，""都是英文字符。

编辑洛书代码时，TAB缩进模式请使用空格，否则会编译出错！


从上述代码中就可以看出，洛书是带有面向对象性质的一门编程语言。

## 编译
先确保你的洛书编程环境已经搭建好，然后在控制台输入：

```
losuc 文件名
```

编译后会在同级目录下产生一个.lsc文件，这就是洛书的解释文件。


在终端输入：
```
losu 文件名.lsc
```
补充：在洛书0.3版本以后，在Windows下双击.lsc文件即可运行(把打开方式设位 losu.exe) ，linux上./?.lsc就ok了。 

根据洛书作者的说法，洛书是一门解释性语言，但是我在它身上看到了java的影子，而非与python相似（doge）

只不过洛书解释后的代码能让人读懂，将源文件翻译后解释而不是直接运行应该是为了优化程序(猜的)。


# 变量与循环结构

## 变量的介绍

基本语法

```
数1 = "1"+"1" //洛书是弱类型的，即使是数字也要加 "",因为"" 代表的是常量而不是字符串
```
洛书的变量是基于相对/绝对变量名来实现作用域的；<br>
\<变量名>代表绝对变量名


```
+类 类一
{
    +方法 方法一(参数一)
        {
            变量一 = "0"
            //参数一 = <[此类·方法一·参数一]>
        }
}
+实例 类一 对象一
+方法 开始()
{
    //变量一 = <对象一·方法一·变量一>
}
```
所以说，洛书的任何一个方法都是支持闭包的<br>只要知道绝对变量名，就可以自由访问、操作任意方法的内部变量

## 循环结构语法

### 基础语法

循环结构为洛书内置函数，使用“+循环”使用。

n为循环次数，可以是常量或变量及表达式。

```
+循环("n")
{
    //循环内容
}
```

### 实际应用

```
//循环语句的使用

+加载 开始

+导入 洛书·标准流

+实例 标准流 标准流

+方法 开始()
{
    标准流·输出("请输入一个人名>")
    
    //这是洛书标准流中的输入方法，分两行写
    标准流·输入()//调用
    人名 = <标准流·输入>//赋值

    +循环("4")
    {
        标准流·输出("你好，" & 人名 & "\n")
    }
   
}

```

# 选择结构

## 单分支

基本语法
```
    +如果 (数1) < ("0")
    {
        //分支内容
    }

```

多分支结构在示例代码中没找到，应该是洛书还未实现该功能。
form 陈朝臣: 确实，洛书默认没有这个功能，可以通过加糖拓展

# 数组

## 基本语法

洛书的数组在标准库中，所以应当在开头导入
```
+导入 洛书·数组
```

并且将其实例化
```
+实例 数组 数组
```

在方法中的使用：

```
这里输入代码
```

洛书数组可以自动扩充大小，不用担心越界
```
数组·设定("数组1","1","你好，洛书\n")
数组·获取("数组1","1")
变量 = <数组·获取>
```
洛书中的数组调用与其它语言大相径庭，要注意先调用，再赋值！（希望洛书以后的版本能改得简单一些）




# 继承
## 基本语法

```
+继承 父类 子类
```
子类中可以拓展新的方法，重写原有方法，同时支持调用已实例的父类中的方法
## 实际应用

```
+加载 开始
+导入 洛书·标准流
+继承 标准流 类一
{
    /{
        这是多行注释
        losu0.3及以上版本支持
    }
    //类的继承，losu0.1开始支持
    +实例 标准流 标准流
    +方法 方法一()
    {
        标准流·输出("你好,洛书编程世界\n")
    }
}
+实例 类一 对象一
+方法 开始()
{
    对象一·方法一()
}
```

# 实例化
洛书的独特之处，实例化一个类时，它所含的方法会被加载到编译·对象缓冲区<br>
当方法被调用时，编译器会静态的加载方法所含内容到输出文件中<br>
当编译结束，缓冲区内所有内容会被删除。<br>
(所以那些实例了但没被调用的垃圾在编译器就被销毁了)