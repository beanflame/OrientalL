#### 从零开始进行构建
##### 技术特点
- 优点 精简，仅包含linux内核与洛书内核，高度可控。
- 缺点 构建时间长，难度高，洛书内核可能要微调。
##### 准备
1. 宿主机 推荐linux环境，也可是虚拟机环境
2. 适合目标平台的linux内核，可以直接粘官方系统里的内核，也可以从源码手动编译。请根据个人能力合理选择。如果用于私人项目，推荐自己编译。具体编译方法可以问度娘
3. 洛书的完整源代码。可以直接下载整个release分支，推荐使用1.0LTS的源码
##### 开始构建
1. 构建设备

创建镜像文件并挂载或直接插入储存设备(比如U盘或TF卡)，以sdb为例

交互式命令创建一个主分区
```
sudo fdisk /dev/sdb
```
在sdb1分区上建立ext4(推荐)文件系统

```
sudo mkfs.ext4 /dev/sdb1
```
2. 安装引导器
UEF引导的设备可以考虑grub，如果是开发板等设备自行安装支持的引导器，这里以grub为例。

- 挂载sdb1到 /mnt 目录 (可以改成其他更方便的目录)
```
sudo mount -t ext4 /dev/sdb1 /mnt
```
- 安装grub，一般是为i386平台安装，也可以手动指定安装方式

```
sudo grub-install --root-directory=/mnt /dev/sdb
```

3. 构建 Losu/Linux内核
+ 制作Linux-init
    - 标准的洛书VM不能作为init进程，会引发“内核恐慌”。
    - 修改losu.cpp，在main()返回前添个死循环，或者专门写个死循环的程序去调用losu。
    - 修改losu.cpp，让它从指定洛书程序(Losu-init，可以放在/losu目录下)开始解释而不是根据命令行参数选择脚本。
    - 如果是小型的嵌入式系统，可以放弃动态库加载，直接将所需功能统一添加到losu.cpp api()函数中，这样可以减少移植动态libc的时间，如果不用多线程，可以直接删去线程有关的代码。
    - 静态编译`g++ -static -o losu losu.cpp -lpthread`，复制到LosuOs中。
- 复制Linux内核，编写grub.cfg(百度搜一下，很好写的)，init指向Linux-init。
4. 调整洛书库
+ 如果放弃了动态库加载，lvm/lsi/lei接口都将失效，可以修改洛书基本类的源码，将对应函数转接到api接口上去。
+ 将调整后的洛书库编译后放在 ！！宿主机！！ 上，不推荐将编译器一起移植过去，编码是个烦人的问题。
5. 编写 Losu-init
在宿主机上随便写个程序，假设调整后的洛书类全部放在了LS_ROOT/inc/LOS目录下，Losu-init指向init.lsc
```
//文件名 init.hetu
#加载 开始
#导入 LOS/标准流
#标准流 系统
#方法 开始()
    #循环("-1")
        系统.输出("Hello,world!\n")
```
```
//文件名 init.losu
+加载 开始
+导入 LOS/标准流
+标准流 系统
+方法 开始()
{
    +循环("-1")
    {
        系统.输出("Hello,world!\n")
    }
}
```

编译生成init.lsc，把它复制到/losu目录下。

6. 构完善根目录

在根目录下创建 sys dev proc 等目录(可以去学一下linux根目录相关知识) ，从作者测试来看，如果仅仅是单独一个输出，有时不加这三个也没事。

7. 启动系统

解挂载设备，从虚拟机或者实体机启动系统，在grub完成引导后，你的屏幕上会不停的划过helloworld，这证明你的LosuOS成功启动了。



