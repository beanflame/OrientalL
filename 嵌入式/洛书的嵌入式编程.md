### 洛书的嵌入式编程
在GNU平台上，洛书可以方便的通过操作/sys/class文件进行嵌入式编程<br>
洛书可以操作gpio等设备操作硬件<br>
洛书的平台无关性意味着，您可以在宿主机编写代码并编译后，<br>
再将其移至嵌入式平台中

### 基本类
+ 引脚

```
+类 引脚
{
    +属性 编号
    +方法 设定(编号,模式)
    {
        /{
            加载并设定指定编号的GPIO
            模式值 
                0 == 输入
                1 == 输出 
        }
        <[此类]·编号> = 编号
        +指令
        {
            add [此类]·设定·编号 lvm gpio ls_gpio_export
            add [此类]·设定·模式 add [此类]·设定·编号 lvm gpio ls_gpio_model
        }
        +回收 编号
        +回收 模式
    }
    +方法 读取()
    {
        +指令
        {
            add [此类]·编号 lvm gpio ls_gpio_read mov [此类]·读取
        }
    }
    +方法 写入(状态)
    {
        +指令
        {
            add [此类]·写入·状态 add [此类]·编号 lvm gpio ls_gpio_value
        }
        +回收 状态
    }
    +方法 卸载()
    {
        +指令
        {
            add [此类]·编号 lvm gpio ls_gpio_unexport
        }
    }
}
```
+ 通用引脚

```
+类 通用引脚
{
    +方法 加载(编号)
    {
        +指令
        {
            add [此类]·加载·编号 lvm gpio ls_gpio_export
        }
        +回收 编号
    }
    +方法 模式(编号,模式)
    {
        +指令
        {
            
            add [此类]·模式·模式 add [此类]·模式·编号 lvm gpio ls_gpio_model
        }
        +回收 编号
        +回收 模式
    }
    +方法 读取(编号)
    {
        +指令
        {
            add [此类]·读取·编号 lvm gpio ls_gpio_read mov [此类]·读取
        }
        +回收 编号
    }
    +方法 写入(编号,状态)
    {
        +指令
        {
            add [此类]·写入·状态 add [此类]·写入·编号 lvm gpio ls_gpio_value
        }
        +回收 编号
        +回收 状态
    }
    +方法 卸载(编号)
    {
        +指令
        {
            add [此类]·卸载·编号 lvm gpio ls_gpio_unexport
        }
        +回收 编号
    }
}
```
你也可以为编写适合您平台的嵌入式类来丰富洛书的功能

### demo
[链接](https://gitee.com/chen-chaochen/lpk/tree/expand/Demo/%E7%89%A9%E8%81%94%E7%BD%91-%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E9%9B%8F%E5%BD%A2)